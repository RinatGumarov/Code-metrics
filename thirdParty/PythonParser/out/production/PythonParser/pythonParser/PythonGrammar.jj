/** * JavaCC template file created by SF JavaCC plugin 1.5.28+ wizard for JavaCC 1.5.0+ */options{  static = false;}PARSER_BEGIN(PythonGrammar)import java.io.File;import java.io.InputStream;import java.io.BufferedReader;import java.io.FileReader;import java.io.PrintStream;import java.io.FileNotFoundException;public class PythonGrammar{  public static int numberLines = 0;  public static int numberAllTokens = 0;  public static int numberTokensInLine = 0;  public static int numberClasses = 0;  public static int numberImports = 0;  public static int numberMethods = 0;  public static int numberReturns = 0;  public static int numberCycles = 0;  public static void main(String args []) throws FileNotFoundException  {    try {        File pathFile;        if (args.length > 0) {            pathFile = new File(args[0]);        }        else {            pathFile = new File("hello.py");        }        BufferedReader br = new BufferedReader(new FileReader(pathFile));        PythonGrammar parser = new PythonGrammar(br);        parser.Start(System.out);    } catch (ParseException e) {    }  }}PARSER_END(PythonGrammar)SKIP :{    <SPACE: (" ")+>}TOKEN :{  < EOL : "\r" | "\n" | "\r\n" >| < INDENT: (" "){4} | "\t"  >}TOKEN :{  < OPERATOR: ((<PLUS>|<MINUS>|<MULTIPLY>|<DIVIDE>|<FLOORDIVIDE>|<POWER>|<LSHIFT>|<RSHIFT>|<MODULUS>|<NOT>|<XOR>|<OR>|<AND>|<EQUAL>|<GREATER>|<LESS>|<EQEQUAL>|<EQLESS>|<EQGREATER>|<LESSGREATER>|<NOTEQUAL>|<PLUSEQ>|<MINUSEQ>|<MULTIPLYEQ>|<DIVIDEEQ>|<FLOORDIVIDEEQ>|<MODULOEQ>|<ANDEQ>|<OREQ>|<XOREQ>|<LSHIFTEQ>|<RSHIFTEQ>|<POWEREQ>)?<SPACE>) >}TOKEN : /* OPERATORS */{    < PLUS: "+" >|   < MINUS: "-" >|   < MULTIPLY: "*" >|   < DIVIDE: "/" >|   < FLOORDIVIDE: "//" >|   < POWER: "**" >|   < LSHIFT: "<<" >|   < RSHIFT: ">>" >|   < MODULUS: "%" >|   < NOT: "~" >|   < XOR: "^" >|   < OR: "|" >|   < AND: "&" >|   < EQUAL: "=" >|   < GREATER: ">" >|   < LESS: "<" >|   < EQEQUAL: "==" >|   < EQLESS: "<=" >|   < EQGREATER: ">=" >|   < LESSGREATER: "<>" >|   < NOTEQUAL: "!=" >|   < PLUSEQ: "+=" >|   < MINUSEQ: "-=" >|   < MULTIPLYEQ: "*=" >|   < DIVIDEEQ: "/=" >|   < FLOORDIVIDEEQ: "//=" >|   < MODULOEQ: "%=" >|   < ANDEQ: "&=" >|   < OREQ: "|=" >|   < XOREQ: "^=" >|   < LSHIFTEQ: "<<=" >|   < RSHIFTEQ: ">>=" >|   < POWEREQ: "**=" >}TOKEN :{  < CONDITION: <GREATER>|<LESS>|<EQEQUAL>|<EQLESS>|<EQGREATER>|<LESSGREATER>|<NOTEQUAL> >}TOKEN : /* BOOLEAN */{    < TRUE : "True" >|   < FALSE : "False" >}TOKEN : /* SEPARATORS */{    < LPAREN: "(" >|   < RPAREN: ")" >|   < LBRACE: "{" >|   < RBRACE: "}" >|   < LBRACKET: "[" >|   < RBRACKET: "]" >|   < SEMICOLON: ";" >|   < COMMA: "," >|   < DOT: "." >|   < COLON: ":" >}TOKEN : /* KEYWORDS */{    < OR_BOOL: "or" >|   < AND_BOOL: "and" >|   < NOT_BOOL: "not" >|   < IS: "is" >|   < IN: "in" >|   < LAMBDA: "lambda" >|   < IF: "if" >|   < ELSE: "else" >|   < ELIF: "elif" >|   < WHILE: "while" >|   < FOR: "for" >|   < TRY: "try" >|   < EXCEPT: "except" >|   < DEF: "def" >|   < CLASS: "class" >|   < FINALLY: "finally" >|   < PRINT: "print" >|   < PASS: "pass" >|   < BREAK: "break" >|   < CONTINUE: "continue" >|   < RETURN: "return" >|   < YIELD: "yield" >|   < IMPORT: "import" >|   < FROM: "from" >|   < DEL: "del" >|   < RAISE: "raise" >|   < GLOBAL: "global" >|   < EXEC: "exec" >|   < ASSERT: "assert" >|   < AS: "as" >|   < WITH: "with" >|   < AT: "@" >|   < RANGE: "range" >}TOKEN : {  < METHOD: <DEF> (<SPACE>)* <NAME> <LPAREN> (<NAME>)* (<COMMA> (<SPACE>)* <NAME>)* <RPAREN> <COLON> >| < CLASSNAME: <CLASS> (<SPACE>)* <NAME> <COLON> >| < RETURNVALUE: <RETURN> (<SPACE>)* ((<NAME>)*(<COMMA> <NAME>)* | <DECNUMBER>) >| < PRINT_COMMAND: <PRINT> <LPAREN> (<NAME>|<DIGIT>)? <RPAREN> >| < CYCLE_FOR: <FOR> (<SPACE>)* <NAME> (<SPACE>)* <IN> (<SPACE>)* <RANGE> <LPAREN> (<DIGIT>)+ <COMMA> (<SPACE>)* (<DIGIT>)+ <RPAREN> <COLON> >| < CYCLE_WHILE: <WHILE> (<TRUE> | ((<SPACE>)* <LPAREN> (<NAME>|<DIGIT>)(<SPACE>)*<CONDITION>(<SPACE>)*(<NAME>|<DIGIT>) <RPAREN>)) <COLON>  >| < IMPORT_LINE: <IMPORT> (<SPACE>)* (((<NAME>) (<COMMA> (<SPACE>)* <NAME>)*)+)>| < IMPORT_LINE_AS: <IMPORT> (<SPACE>)* (<NAME> (<SPACE>)* <AS> (<SPACE>)* <NAME> (<SPACE>)*)+ >}TOKEN : { <STRING: "\"" (~["\"", "\\"] | "\\\"" | "\\\\")* "\"" > }TOKEN : /* Python identifiers */{    < NAME: <LETTER> ( <LETTER> | <DIGIT> )* >|   < #LETTER: ["_","a"-"z","A"-"Z"] >}TOKEN : /* Numeric literals */{    < DECNUMBER:        ["1"-"9"] (["0"-"9"])* (["l", "L"])?      | "0"      >|   < HEXNUMBER: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+ (["l","L"])? >|   < OCTNUMBER: "0" (["0"-"7"])* (["l","L"])? >|    < FLOAT:        (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)?      | "." (["0"-"9"])+ (<EXPONENT>)?      | (["0"-"9"])+ <EXPONENT>      >|   < COMPLEX: (<DECNUMBER> | <FLOAT> | "0" <DECNUMBER> ) ["j", "J"]>|   < #EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >|   < #DIGIT: ["0" - "9"] >}void Start(PrintStream printStream) throws NumberFormatException :{}{    (        Line(printStream)        EndOfLine(printStream)    )*    Log(printStream)    <EOF>}void EndOfLine(PrintStream stream) :{}{    (<EOL>    {        numberLines += 1;    })*}void Line(PrintStream stream) :{}{        Command(stream)    |        Code(stream)    |        Expression()}void Log(PrintStream stream) :{}{    {        int temp = numberTokensInLine;        numberTokensInLine = 0;        stream.println("Number lines: " + numberLines);        stream.println("Number all tokens in file: " + numberAllTokens);        stream.println("Number imports: " + numberImports);        stream.println("Number classes in file: " + numberClasses);        stream.println("Number methods in file: " + numberMethods);        stream.println("Number return: " + numberReturns);        stream.println("Number cycles: " + numberCycles);        {            if (numberAllTokens < 100) {                stream.println("Complexity level: low");            }            if (numberAllTokens > 100 && numberAllTokens < 150) {                stream.println("Complexity level: medium");            }            if (numberAllTokens > 150) {                stream.println("Complexity level: high");            }        }        stream.println();    }}void Code(PrintStream stream) :{}{        <INDENT>        {            numberTokensInLine += 1;            numberAllTokens += 1;        }    |        (<NAME>)+ (<OPERATOR> (<DECNUMBER> | <NAME>))*        {            numberTokensInLine += 3;            numberAllTokens += 3;        }}void Command(PrintStream stream) :{    String s;}{        <PRINT_COMMAND>        {            numberTokensInLine += 4;            numberAllTokens += 4;        }    |        <CLASSNAME>        {            numberClasses += 1;            numberTokensInLine += 3;            numberAllTokens += 3;        }    |        <METHOD>        {            numberMethods += 1;            numberTokensInLine += 8;            numberAllTokens += 8;        }    |        <RETURNVALUE>        {            numberReturns += 1;            numberTokensInLine += 3;            numberAllTokens += 3;        }    |        <CYCLE_FOR>        {            numberCycles += 1;            numberTokensInLine += 10;            numberAllTokens += 10;        }    |        <CYCLE_WHILE>        {            numberCycles += 1;            numberTokensInLine += 7;            numberAllTokens += 7;        }    |        <IMPORT_LINE>        {            numberImports += 1;        }    |        <IMPORT_LINE_AS>        {            numberImports += 1;        }}void Parameters(PrintStream stream) :{    double d;    String s;}{    <LPAREN> s = PrimaryString() <RPAREN>    { stream.println(s); }}double Expression() throws NumberFormatException :{    double i;    double value;}{    value = Term()    (        <PLUS>        {            numberTokensInLine += 1;            numberAllTokens += 1;        }        i = Term()        { value += i; }    |        <MINUS>        {            numberTokensInLine += 1;            numberAllTokens += 1;        }        i = Term()        { value -= i; }    )*    { return value; }}double Term() throws NumberFormatException :{    double i;    double value;}{    value = Primary()    (        <MULTIPLY>        {            numberTokensInLine += 1;            numberAllTokens += 1;        }        i = Primary()        { value *= i; }    |        <DIVIDE>        {            numberTokensInLine += 1;            numberAllTokens += 1;        }        i = Primary()        { value /= i; }    |        <MODULUS>        {            numberTokensInLine += 1;            numberAllTokens += 1;        }        i = Primary()        { value %= i; }    |        <POWER>        {            numberTokensInLine += 1;            numberAllTokens += 1;        }        i = Primary()        { value = Math.pow(value, i); }    )*    { return value; }}double Primary() throws NumberFormatException :{    Token t;    double d;}{        t = <DECNUMBER>        {            numberTokensInLine += 1;            numberAllTokens += 1;        }        { return Double.parseDouble(t.image); }    |        <LPAREN> d = Expression() <RPAREN>        {            numberTokensInLine += 2;            numberAllTokens += 2;        }        { return d; }    |        <MINUS> d = Primary()        {            numberTokensInLine += 1;            numberAllTokens += 1;        }        { return -d; }}String PrimaryString() :{    Token t;}{        t = <DECNUMBER>        { return t.image; }}